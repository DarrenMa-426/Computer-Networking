# 传输控制协议
传输控制协议（Transfer Control Protocol，TCP）是一个面向连接可靠的协议。TCP 显式定义了连接建立、数据传输以及连接拆除阶段来提供面向连接服务。TCP 使用 GBN 和 SR 协议的组合来提供可靠性。为了实现这个目的，TCP 使用校验和（为差错发现）、丢失或被破坏分组重传、累积和选择确认以及计时器。

## 流传递服务
+ TCP 允许发送进程以字节流形式传递数据，并且接收进程也以字节流形式接收数据。TCP 建立一种环境，在这种环境中，两个进程好像由一个假想的”管道“连接，这个管道通过因特网传送这些进程的数据。
+ 发送和接收缓冲区
  + 因为发送和接收进程可能以不同的速度写入和读出数据，所以 TCP 需要用于存储的缓冲区。
  + 每个方向都存在一个缓冲区：发送缓冲区和接收缓冲区。
  + 这些缓冲区也用于 TCP 流量和差错控制机制。
  + 发送缓冲区：灰色存储单元的字节被确认后，这些存储单元可以回收并且对发送进程可用。
  + 回收缓冲区：当某个字节被接收进程独处以后，这个存储单元可被回收，并加入到空存储单元池中。
+ IP 层作为 TCP 服务的提供者，需要以分组的方式而不是字节流的方式发送数据。在传输层，TCP 将多个字节组合在一起成为一个分组，这个分组称为段（segment）。
+ TCP 提供全双工服务，即数据可以在同一时间双向流动。每一方向 TCP 都有发送和接收缓冲区，它们能在双向发送和接收段。
+ 逻辑连接
  + 在两个 TCP 之间建立一个连接；
  + 在两个方向交换数据；
  + 连接终止；
+ TCP 是一种可靠的传输协议。它使用确认机制来检查数据是否安全和完整的到达。

## TCP 的特点
+ TCP 在段的头部采用称为序号（sequence number）和确认号（acknowledgment number）的两个字段。这两个字段指的是字节序号，而不是段序号
+ 字节序号
  + TCP 为在一个连接中传输的所有数据字节（八位字节）编号。在每个方向上序号都是独立的。
  + 当 TCP 接收来自进程（应用层）的一些数据字节时，TCP 将它们存储在发送缓冲区中并给它们编号。
  + TCP 在 0 到 2 的 32 次方 - 1 之间生成一个随机数作为第一个字节的序号。（例如，如果随机数是 1057，而且发送的全部字节个数是 6000，那么这些字节序号是 1057~7056。
  + 在每个连接中传送的字节都由 TCP 编号，序号开始于一个随机产生的数。
+ （段）序号
  + 第一段的序号是初始序号（initial sequence number，ISN），这是一个随机数。
  + 其他段的序号是之前段的序号加之前段携带的字节数（实际上的或想象的）。之后，我们将给出一些控制端，它们被认为携带了一个想象字节。
  + 一个段的序号字段的值定义了该段包含的第一个字节的序号。
+ 确认号
  + 确认号定义了该方预期接收的下一个字节的序号。
  + 术语“累积”指的是，如果一方使用 5643 作为确认号，则表示它已经接收了所有从开始到序号为 5642 的字节。
  + 段中确认字段的值定义了通信一方预期接收的下一个字节的编号。确认号是累积的。
+ 段
  + 段包含 20 字节到 60 字节的头部，接下来是应用程序的数据。
  + 源端口地址；
  + 目的端口地址；
  + 序号：这个 32 位的字段定义了一个数，它分配给段中数据的第一个字节；
  + 确认号：这个 32 位的字段定义了段的接收方期望从对方接收的字节号；
  + 头部长度；
  + 控制：这个字段定义了 6 种不同的控制位或标记；
    + URG：紧急指针有效；
    + ACK：确认有效；
    + PSH：请求推送；
    + SYN：同步序号；
    + FIN：终止连接；
  + 窗口大小：这个字段定义对方必须维持的窗口的大小。这个值通常称为接收窗口（rwnd），它由接收方确定。此时，发送必须服从接收端的支配。
  + 校验和：与 UDP 协议一样，用于校验，但是 TCP 协议中，该值为必填项。
  + 紧急指示符：这个 16 位的字段只有当仅仅标置位时才有效，这个段包含了紧急数据。
  + 选项；
  
## TCP 连接
+ TCP 是一个面向连接的协议。面向连接的传输协议在源端和目的端之间建立一条虚路径。然后，属于一个报文的所有段都沿着这条虚路径发送。
+ 在 TCP 中，面向连接的传输需要三个过程：连接建立、数据传输和连接终止。

### TCP - 连接建立
+ 当客户（应用程序）想与服务器（应用程序）使用 TCP 作为传输层协议建立连接时。
+ 服务器程序告诉它的 TCP，它已准备好接收一个连接。这称为被动打开（passive open）。
+ 客户程序发出请求进行主动打开（active open）。想要与服务器进行连接的客户告诉它的 TCP，它需要连接到指定的服务器。
+ 三次握手
  + 客户发送的第一个段是 SYN 段。这个段仅有 SYN 标志被置位，它用于序号同步。它占用一个序号。SYN 段是一个控制段且不携带数据。然而，它消耗一个序号，因为它需要被确认。
  + 服务器发送第二个段，两个标志位 SYN 和 ACK 置位的段，即 SYN + ACK 段。这个段有两个目的。首先，它是另一方向通信的 SYN 段。服务器用这个段来初始化序号，这个序号用来给从服务器发给客户的字节编号。服务器也通过给 ACK 置位并展示下一个序号来确认接收来自客户的 SYN 段，这里的下一序号是服务器预期从客户接收的序号。因为它包含确认，它也需要定义接收窗口，即 rwnd（客户使用）。因为这个段起到了 SYN 段的作用，它需要被确认。SYN + ACK 段不携带数据，但它占用一个序号。
  + 客户发送第三个段。这个段仅仅是一个 ACK 段。它使用 ACK 标志和确认序号字段来确认收到了第二个段。注意，如果不携带数据，ACK 段没有占用任何序号，但是一些实现允许第三个段在连接阶段从客户端携带第一块数据。
+ SYN 泛洪攻击
  + 一个恶意的攻击者将大量的 SYN 段发送到一个服务器，在数据报中通过伪装源 IP 地址假装这些 SYN 段是来自不同的客户端，此时就是 SYN 泛洪攻击。
  + 假定客户机发出主动打开，服务器分配必要的资源，如生成转换控制块（TCB）和设置计时器等。然后服务器发送 SYN+ACK 段给这些假客户，但这些段都丢失了。
  + 。然而，当服务器等待第三段握手过程时，许多资源被占用但没有被使用。
  + 如果在短时间内，SYN 段的数量很大，服务器最终会耗尽资源而崩溃。
  + 这种 SYN 泛洪攻击属于一种称为拒绝服务攻击（denial of service attack）的安全攻击类型，其中，一个攻击者独占系统如此多的服务请求使得系统崩溃，拒绝对每个请求提供服务。

### TCP - 数据传输
+ 连接建立后，可进行双向数据传输，客户端与服务器双方都可发送数据和确认。
+ 客户端发送的数据段有 PSH（推送）标志，所以服务器 TCP 知道在接收到数据时立刻传递给服务器进程。（来自服务器的端没有设置推送标志）
+ 发送方的 TCP 使用缓冲区来存储来自发送方应用程序的数据流，接收方的 TCP 在数据到达时也将数据进行缓存，并当应用程序准备就绪时或当接收端 TCP 认为方便时将这些数据传递给应用程序。这种灵活性增加了 TCP 的效率。（这个特性可选择用或不用）
+ 在某些情况下，应用程序需要发送紧急（urgent）字节，某些字节需要另一端的应用以特殊方式对待。解决方法是发送一个 URG 标志置位的段。发送应用程序告诉发送端的 TCP，这块数据是紧急的。发送端 TCP 创建段，并将紧急数据放在段的开始。

### TCP - 连接终止
+ 当前大多数对连接终止的实现有两个方法：三次握手和带有半关闭选项的四次挥手。
+ 三次握手
  + 在正常情况下，在客户进程接收到一个关闭命令后，客户的 TCP 发送第一个段：FIN 段，即其中的 FIN 标志置位。FIN 段可包含客户机要发送的最后数据块，如果 FIN 端不携带数据，则该段占用一个序号。
  + 服务器 TCP 接收到 FIN 段后，通知它的进程，并发送第二个段：FIN + ACK 段，证实它接收到来自客户端的 FIN 段，同时通知另一端连接关闭。这个段还可以包含来自服务器的最后数据块。如果它不携带数据，则这个段仅占用一个序号。
  + 客户端的 TCP 发送最后一段，即 ACK 段，来证实它接收到来自服务器的 FIN 段。这个段包含确认号，它是来自服务器的 FIN 端序号加 1。这个段不携带数据也不占用序号。
+ 四次挥手
  + 在 TCP 中，一端可以停止发送数据后，还可以持续接收数据，这就是所谓的半关闭。
  + 在三次握手的第二步中，仅发送 ACK 段，在服务器向客户端数据传输完毕后，再由服务器向客户端发送 FIN 段，将第二步拆解成两两步，就是四次挥手。

### TCP - 连接重置
+ 在一端的 TCP 可能拒绝连接请求，可能终止已存在的连接，也可能结束空闲连接。所有这些都通过 RST（重置）标志完成。

## TCP 中的窗口
+ TCP 在每个方向的数据传输上使用两个窗口（发送窗口和接收窗口），这意味着双向通信有四个窗口。 
+ TCP 的发送窗口与选择性重复协议中的发送接口的不同之处
  + 窗口相关的实体本质不同；在 SR 中窗口的大小是分组的数量，但是 TCP 中的窗口大小是字节的数量。尽管 TCP 中实际传输是一段接一段发生的，但是控制窗口的变量是以字节（Byte）为单位的。
  + 在某些实现中，TCP 可以存储来自进程的数据并且在之后发送它们，但是我们假设发送 TCP 一旦从进程中接收到数据就能够发送数据段。
  + 选择性重复协议可能为每个被发送的分组使用多个计时器，而 TCP 只使用一个计时器。
+ TCP 中的接收窗口与 SR 中的接收窗口的不同：
  + TCP 允许接收进程以自己的速率拉数据。这意味着接收方被分配缓冲区可以被已接收且确认的字节占据，但是它们正在等待被接收进程拉过去。接收窗口大小总是小于或等于缓冲区大小。接收窗口大小决定了接收窗口在被淹没（流量控制）之前可以从发送方接收的字节数量。换言之，接收窗口通常称为 rwnd， rwnd = 缓冲区大小 - 等待被拉字节数量。
  + TCP 的新版本使用了累积确认和选择性确认。

### 流量控制
+ 流量控制反馈是从接收方 TCP 传输到发送方 TCP 并且从发送方 TCP 上升到发送方进程。接收方 TCP 控制发送方 TCP，发送方 TCP 控制发送方进程。当窗口已满，接收方拒绝发送方 TCP 的数据。
+ 打开以及关闭窗口
  + 为了实现流量控制，TCP 迫使发送方和接收方调整它们的窗口大小，尽管当连接建立时两方的缓冲区大小是固定的。当更多的数据从发送方到来时，接收方窗口关闭（向右移动左沿）；当更多的数据被进程拉进来时，它打开窗口（向右移动右沿）；
+ 窗口收缩
  + 接收窗口不能收缩，发送方可以收缩（部分实现不能收缩）。
  + 接收方需要通过下面的公式来防止发送窗口收缩：
  + 新 ackNo + 新 rwnd >= 上一个 ackNo + 上一个 rwnd
+ 窗口关闭：接收方可以通过发 rwnd 为 0 来临时关闭窗口，这只会在某些原因下发生，即接收方在一段时间内不想接收来自发送方的任何数据。

### 差错控制
+ TCP 是一个可靠的传输层协议。这意味着将数据流传递给 TCP 的应用程序依靠 TCP 将整个数据流传递给另一端的应用程序，并且是按序的、无差错的、没有任何一部分丢失或重复的。
+ 校验和：每个段都包括校验和字段，用来检查损坏的段，如果段被损坏，它将被目的端 TCP 丢弃，并被认为是丢失了。
+ 确认：TCP 使用确认方法来证实收到了数据段。不携带数据但占用序号的一些控制端也要确认，但是 ACK 段是不确认的，也不占用序号。
+ 确认类型：
  + 累积确认（ACK）：最初的 TCP 被设计成累积确认接收段。接收方通告下一个预期接收的字段，忽略所有失序段。
  + 选择性确认（SACK）：SACK 并不替代 ACK，但它向发送方报告额外的信息，SACK 报告失序字节块，也报告重复字节块即接收了一次以上的字节块。
+ 接收端产生确认的规则：
  + 当终端 A 向终端 B 发送一个数据段时，它必须包含（捎带）一个确认，这个确认给出下一个期待接收的序号。这个规则降低了所需段的数量，因此减少了通信量。
  + 当接收方没有数据要发送并接收到一个有序段（带有预期序号），并且之前的段已经被确认，那么接收方延迟发送 ACK 段直到另一个段到达，或者过一段时间之后（通常 500 ms）。换言之，如果只有一个未完成的有序段，那么接收方需要延迟发送 ACK 段。这个规则减少了 ACK 段。
  + 当一个带有接收方预期序号的段到达，且之前一个有序段未被确认，接收方立即发送一个 ACK 段。换言之，任何时候不能多于两个有序的未确认段存在。这防止了不必要的重传，它可能引起网络阻塞。
  + 当一个失序段到达，且它的序号大于预期，那么接收方立即发送一个 ACK 段，声明下一个预期段的序号。这导致了丢失段的快速重传。
  + 当一个丢失段到达，接收方发送一个 ACK 段，声明下一个预期序号。这通知接收方被报告丢失的段已经到达。
  + 如果重复段到达，接收方丢弃段，但是立即发送一个确认指出下一个预期的 有序段。这个方法解决了当 ACK 丢失时的一些问题。
+ 失序段
  + 数据可以失序到达，并被接收的 TCP 临时存储。但是 TCP 确保传递给进程的段是非失序的；接收方 TCP 仅将有序的数据传递给进程。

### TCP 拥塞控制
+ 拥塞窗口
  + rwnd 能保证接收窗口不会被接收字节溢出，但是不能保证中间缓冲区、路由器中的缓冲区不会变的拥塞。路由器中的拥塞是在 IP 域中，但是 IP 是一个没有拥塞控制的简单协议，TCP 自身需要为这个问题负责。
  + TCP 不能忽略网络中的拥塞问题，它不能过分激进地向网络中发送段；也不能过于保守，这样的话不能有效的利用好网络可用带宽。
  + TCP 使用称为拥塞窗口（congestion window，cwnd）的变量来控制段的发送数量，这个变量的值由网络中的拥塞情况所控制。
+ 拥塞检测
  + TCP 发送使用两个事件作为网络中拥塞的标志：超时和接收到三次重复 ACK。
  + 接收到三次重复 ACK（四个带有相同确认号的 ACK）。当 TCP 接收方发送一个重复 ACK，这是段已经被延迟的信号，但是发送三次重复 ACK 是丢失段的标志，这可能是由于网络拥塞造成的。
  + TCP 发送方只使用一种反馈来从另一端检测拥塞：即 ACK。没有周期性地、及时地接收到 ACK，这导致超时，是严重拥塞的标志；接到三次重复 ACK 是网络中轻微拥塞的标志。
+ 拥塞策略：TCP 处理拥塞的一般策略基于三个算法
  + 慢启动：指数增加；
  + 拥塞避免：加性增加；
  + 快速恢复：加性增加；
+ 三种 TCP 版本
  + Taho TCP：慢启动和拥塞避免；
  + Reno TCP：慢启动、拥塞避免和快速回复；
  + NewReno TCP：优化；

### TCP 计时器
+ 为了更平稳地执行操作，绝大多数 TCP 实现使用至少四种计时器：重传、坚持、保活和时间等待计时器。
  + 重传计时器：为了重传丢失的段，TCP 使用一种重传计时器（在整个连接期间）处理重传超时（RTO），即对一个端的确认等待时间。
  + 坚持计数器：为了处理 0 窗口大小通告引起的死锁问题，TCP 为每个连接使用坚持计时器。当发送方 TCP 接收一个窗口大小为 0 的确认时，开启坚持计时器。当坚持计时器到时，发送方 TCP 发送一个特殊的段，称为探测（probe）。这个段只包含一字节的新数据。它有一个序号，但是序号从不被确认；在为剩余的数据计算序号时它甚至被忽略。探测报文引发接收方 TCP 重发确认。
  + 保活计时器：保活计时器（keep-alive timer）通常在某些实现中使用，来防止两个 TCP 之间的长期空闲连接。
  + 时间等待计时器：时间等待（TIME-WAIT）计时器在连接终止期间使用。